<!DOCTYPE html>
<html>
    <title>Noah Lewis (Personal Website)</title>
    <link rel="stylesheet" href="../../styles.css">
    <body>
        <h1><a href="/">Noah Lewis (Personal Website)</a></h1>
        <hr>
        <h2>Introduction Answers</h2>
        <p>
            This page provides an answers for chapter 1 (Introduction)
            of the book "Modern Operating Systems".
        </p>
        <hr>
        <h2>Question & Answers</h2>
        <h3>Problem 1</h3>
        <p>What are the two main functions of an operating system?</p>
        <h3>Answer Problem 1</h3>
        <ol>
            <li>Provide users with good abstractions</li>
            <li>Managing devices and resources</li>
        </ol>

        <h3>Problem 2</h3>
        <p>
            In Section 1.4, nine different types of operating systems are described. 
            Give a list of applications for each of these systems (one per operating systems type).
        </p>
        <h3>Answer Problem 2</h3>
        <ol>
        <li><b>Mainframe Operating Systems</b>: Bank transaction system</li>
        <li><b>Server Operating Systems</b>: HTTP servers</li>
        <li><b>Multiprocessor Operating Systems</b>: Scientific simulations</li>
        <li><b>Personal Computer Operating Systems</b>: Word processing</li>
        <li><b>Handheld Computer Operating Systems</b>: Phone calls and text message</li>
        <li><b>Embedded Operating Systems</b>: Music playing software (MP2 player)</li>
        <li><b>Sensor-node operating system</b>: Temperature sensors</li>
        <li><b>Real-time operating systems</b>: Manufacturing assembly line</li>
        <li><b>Smart card operating systems</b>: Electronic payments</li>
        </ol>

        <h3>Problem 3</h3>
        <p>What is the difference between timesharing and multiprogramming systems?</p>
        <h3>Answer Problem 3</h3>
        <p>
            In a timesharing system, multiple interactive users are managed each of which 
            can perform multiprogramming. Multiprogramming simply means multiple 
            processes can run concurrently.
        </p>

        <h3>Problem 4</h3>
        <p>
            To use cache memory, main memory is divided into cache lines, typically 32 
            or 64 bytes long. An entire cache line is cached at once. What is the advantage 
            of caching an entire line instead of a single byte or word at a time?
        </p>
        <h3>Answer Problem 4</h3>
        <p>
            Imagine caching was done with byte level granularity and the user will 
            access 64 bytes contiguously. There will be 64 cache misses. Whereas if 
            the cache lines are 64 bytes then there will be a single cache miss for 
            the first byte at which point the following 63 bytes are cached.
        </p>

        <h3>Problem 5</h3>
        <p>
            On early computers, every byte of data read or written was handled by the 
            CPU (i.e., there was no DMA). What implications does this have for multiprogramming?
        </p>
        <h3>Answer Problem 5</h3>
        <p>
            If each byte read/written is managed by the CPU then when multiple 
            processes are running the OS must manage in what order processes 
            receive/send the data requested. This would increase CPU contention 
            tremendously decreasing performance.
        </p>

        <h3>Problem 6</h3>
        <p>
            Instructions related to accessing I/O devices are typically privileged 
            instructions, that is, they can be executed in kernel mode but not in user mode. 
            Give a reason why these instructions are privileged.
        </p>
        <h3>Answer Problem 6</h3>
        <p>
            If I/O instructions are available in userspace there is nothing preventing 
            bad (malicious or buggy) processes from incorrectly interacting with devices.
        </p>

        <h3>Problem 7</h3>
        <p>
            The family-of-computers idea was introduced in the 1960s with 
            the IBM System/360 mainframes. Is this idea now dead as a doornail 
            or does it live on?
        </p>
        <h3>Answer Problem 7</h3>
        <p>This is still alive and well. An example includes the x86 CPU family.</p>

        <h3>Problem 8</h3>
        <p>
            One reason GUIs were initially slow to be adopted was the cost of the hardware 
            needed to support them. How much video RAM is needed to support a 25-line x 80-row 
            character monochrome text screen? How much for a 1200 x 900-pixel 24-bit color bitmap? 
            What was the cost of this RAM at 1980 prices ($5/KB)? How much is it now?
        </p>
        <h3>Answer Problem 8</h3>
        <p>RAM for 25-line x 80-column monochrome text screen: 25 x 80 = 2,000 bytes</p>
        <p>RAM for 1200 x 900-pixel 24-bit color bitmap: 1200 x 900 x 3 = 3,240,000 bytes</p>
        <p>
            Assuming decimal kilobytes (1 KB = 1,000 bytes), this is approximately 3,240 KB of memory.
        </p>
        <p>Price for 3,240 KB of memory in 1980 at $5 per KB: $16,200</p>
        <p>Price for 3,240 KB of memory in 2025 at $0.00000214577 per KB: approximately $0.00695</p>

        <h3>Problem 9</h3>
        <p>
            There are several design goals in building an operating system, for example, 
            resource utilization, timeliness, robustness, and so on. Give an example of 
            two design goals that may contradict one another.
        </p>
        <h3>Answer Problem 9</h3>
        <p>Correctness and speed (especially in the context of multiprocessor programming).</p>

        <h3>Problem 10</h3>
        <p>
            What is the difference between kernel and user mode? Explain how having two 
            distinct modes aids in designing an operating system.
        </p>
        <h3>Answer Problem 10</h3>
        <p>
            Kernel mode grants access to specialized CPU instructions only available when 
            the CPU is at a specific ring level.</p>
        <p>
            Kernel level drivers have full responsibility for ensuring devices are used correctly. 
            By decoupling the kernel from userspace,
            the kernel can provide abstractions (APIs) which userspace programs can use. 
            This allows for the underlying implementation of these
            APIs to be changed without breaking userspace (most of the time :)...).
        </p>

        <h3>Problem 11</h3>
        <p>
            A 255-GB disk has 65,536 cylinders with 255 sectors per track and 512 bytes 
            per sector. How many platters and heads does this disk have? Assuming an 
            average cylinder seek time of 11 ms, average rotational delay of 7 msec and 
            reading rate of 100 MB/sec, calculate the average time it will take to 
            read 400 KB from one sector.</p>
        <h3>Answer Problem 11</h3>
        <p>Number of platters: (total_data / data_per_platter_side) 
            / 2_sides_per_platter = (255 GB / (65536 * 255 * 512) B) / 2 = 16</p>
        <p>Number of heads: 16 * 2 = 32 heads</p>
        <p>400 KB / 512 B = ceiling(781.25) = 782 sectors</p>
        <p>Average time = 782 * (11 ms + 7 ms + 5.12 * 10^(-6)) = 14.06 sec</p>
        <p>This answer assumes sectors are randomly scattered on disk and not contiguous.</p>
        <h3>Problem 12</h3>
        <p>
            Which of the following instructions should be allowed only in kernel mode?
            <br>(a) Disable all interrupts.<br>
            (b) Read the time-of-day clock.<br>
            (c) Set the time-of-day clock.<br>
            (d) Change the memory map.
        </p>
        <h3>Answer Problem 12</h3>
        <p>
            (a) YES<br>
            (b) NO<br>
            (c) YES<br>
            (d) YES
        </p>

        <h3>Problem 13</h3>
        <p>
            Consider a system that has two CPUs, each CPU having two threads (hyperthreading).
            Suppose three programs, P0, P1, and P2, are started with run times of 5, 10 and 20
            msec, respectively. How long will it take to complete the execution of these programs?
            Assume that all three programs are 100% CPU bound, do not block during execution,
            and do not change CPUs once assigned.
        </p>
        <h3>Answer Problem 13</h3>
        <p>
            The system can run up to 4 threads in parallel. P0 and P1 finish in 5 and 10 msec respectively. P2 finishes in 20 msec.<br>
            Timeline:<br>
            msec: 0123456789012345678901234<br>
            P0:   -----<br>
            P1:   ----------<br>
            P2:        --------------------<br>
            Total time: 25 msec
        </p>

        <h3>Problem 14</h3>
        <p>
            A computer has a pipeline with four stages. Each stage takes the same time to do its
            work, namely, 1 nsec. How many instructions per second can this machine execute?
        </p>
        <h3>Answer Problem 14</h3>
        <p>
            Once the pipeline is filled, one instruction completes every 1 nsec.<br>
            So the system can execute 1 billion (10<sup>9</sup>) instructions/sec.<br>
            Note: the first instruction takes 4 nsec, but this is amortized over many instructions.
        </p>

        <h3>Problem 15</h3>
        <p>
            Consider a computer system that has cache memory, main memory (RAM), and disk,
            and an operating system that uses virtual memory. It takes 1 nsec to access a word
            from the cache, 10 nsec to access a word from the RAM, and 10 ms to access a word
            from the disk. If the cache hit rate is 95% and main memory hit rate (after a cache
            miss) is 99%, what is the average time to access a word?
        </p>
        <h3>Answer Problem 15</h3>
        <p>
            Average access time = (1 ns * 0.95) + ((1 ns + 10 ns) * 0.99 * 0.05) + ((1 ns + 10 ns + 10 ms) * 0.01 * 0.05)<br>
            = 0.95 ns + 0.5445 ns + 5000 ns ≈ 5001.5 ns
        </p>

        <h3>Problem 16</h3>
        <p>
            When a user program makes a system call to read or write a disk file, it provides an
            indication of which file it wants, a pointer to the data buffer, and the count. Control is
            then transferred to the OS, which calls the appropriate driver. Suppose the driver
            starts the disk and terminates until an interrupt occurs. In the case of reading, the
            caller blocks. What about writing to the disk? Must the caller be blocked?
        </p>
        <h3>Answer Problem 16</h3>
        <p>
            No, writing can often be performed asynchronously. The OS may buffer the write and return
            control to the caller before the physical write completes. The caller can later sync the
            file system if needed.
        </p>

        <h3>Problem 17</h3>
        <p>
            What is a trap instruction? Explain its use in operating systems.
        </p>
        <h3>Answer Problem 17</h3>
        <p>
            A trap instruction switches execution from user mode to kernel mode. It is the mechanism 
            by which system calls are implemented, allowing user programs to request services from 
            the operating system securely.
        </p>

        <h3>Problem 18</h3>
        <p>
            Why is the process table needed in a timesharing system? Is it also needed in personal
            computer systems running UNIX or Windows with a single user?
        </p>
        <h3>Answer Problem 18</h3>
        <p>
            The process table tracks active processes and their states. Even in a single-user system, 
            multiple processes (apps, services) run concurrently, so the OS needs the process table 
            to manage them.
        </p>

        <h3>Problem 19</h3>
        <p>
            Is there any reason why you might want to mount a file system on a nonempty directory?
            If so, what is it?
        </p>
        <h3>Answer Problem 19</h3>
        <p>
            Yes, mounting over a nonempty directory can be used to temporarily hide its contents.
            This can be useful to mask sensitive or irrelevant files, or to override parts of the directory tree.
        </p>

        <h3>Problem 20</h3>
        <p>
            For each of the following system calls, give a condition that causes it to fail: 
            fork, exec, and unlink.
        </p>
        <h3>Answer Problem 20</h3>
        <p>
            <strong>fork</strong>: Not enough system resources (e.g., memory or process table full).<br>
            <strong>exec</strong>: Executable file is missing, not permitted, or of an unsupported format.<br>
            <strong>unlink</strong>: File does not exist or permission denied.
        </p>

        <h3>Problem 21</h3>
        <p>
            What type of multiplexing (time, space, or both) can be used for sharing the following
            resources: CPU, memory, disk, network card, printer, keyboard, and display?
        </p>
        <h3>Answer Problem 21</h3>
        <p>
            CPU – Time<br>
            Memory – Space<br>
            Disk – Space<br>
            Network Card – Time<br>
            Printer – Both<br>
            Keyboard – Time<br>
            Display – Time
        </p>

        <h3>Problem 22</h3>
        <p>
            Can the <code>count = write(fd, buffer, nbytes);</code> call return any value in <code>count</code> other than <code>nbytes</code>? If so, why?
        </p>
        <h3>Answer Problem 22</h3>
        <p>
            Yes. If there is insufficient space or an error occurs partway through, <code>write</code> may write only some of the bytes 
            and return the actual number written. The caller must check the return value.
        </p>

        <h3>Problem 23</h3>
        <p>
            A file whose file descriptor is <code>fd</code> contains the following bytes: 3, 1, 4, 1, 5,
            9, 2, 6, 5, 3, 5. The following system calls are made:
            <code>lseek(fd, 3, SEEK_SET);</code>
            <code>read(fd, &buffer, 4);</code>
            What does buffer contain after the read has completed?
        </p>
        <h3>Answer Problem 23</h3>
        <p>
            The seek moves the file pointer to byte 3 (zero-indexed), which contains the value 1.<br>
            Reading 4 bytes gives: 1, 5, 9, 2<br>
            So <code>buffer</code> contains: 1, 5, 9, 2
        </p>
    </body>
</html>