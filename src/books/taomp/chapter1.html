<!DOCTYPE html>
<html>
    <title>Noah Lewis (Personal Website)</title>
    <link rel="stylesheet" href="../../styles.css">
    <body>
        <h1><a href="/">Noah Lewis (Personal Website)</a></h1>
        <hr>
        <h2>Introduction Answers</h2>
        <p>
            This page provides an answers for chapter 1 (Introduction)
            of the book "The Art of Multiprocessor Programming".
        </p>
        <hr>
        <h2>Question & Answers</h2>
        <h3>Problem 1</h3>
        <p>
            The dining philosophers problem was invented by E. W. Dijkstra, a
            concurrency pioneer, to clarify the notions of deadlock and starvation freedom.
            Imagine ﬁve philosophers who spend their lives just thinking and feasting. They
            sit around a circular table with ﬁve chairs. The table has a big plate of rice. How-
            ever, there are only ﬁve chopsticks (in the original formulation forks) available,
            as shown in Fig. 1.5. Each philosopher thinks. When he gets hungry, he sits down
            and picks up the two chopsticks that are closest to him. If a philosopher can pick
            up both chopsticks, he can eat for a while. After a philosopher ﬁnishes eating, he
            puts down the chopsticks and again starts to think.
        </p>
        <p>
            1. Write a program to simulate the behavior of the philosophers, where each
            philosopher is a thread and the chopsticks are shared objects. Notice that you
            must prevent a situation where two philosophers hold the same chopstick at
            the same time.
        </p>
        <p>
            2. Amend your program so that it never reaches a state where philosophers are
            deadlocked, that is, it is never the case that each philosopher holds one chop-
            stick and is stuck waiting for another to get the second chopstick.
        </p>
        <p>
            3. Amend your program so that no philosopher ever starves.
        </p>
        <p>
            4. Write a program to provide a starvation-free solution for any number of
            philosophers n.
        </p>
        <h3>Answer Problem 1 Part 1</h3>
        <pre class="code-block">        
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Main extends Thread {
    static int num_philosophers = 5;
    static List<Lock> chopsticks = new ArrayList<>();
    static int eat_time_millis = 500;
    
    int philosopher_id;
    
    public Main(int philosopher_id) {
        this.philosopher_id = philosopher_id;
    }
    
    public static void main(String[] args) {
        if(num_philosophers < 5) {
            System.out.println("num_philosophers must be at least 5!");
            return;
        }
        
        List<Thread> philosophers = new ArrayList<>();
        
        for(int i = 0; i < num_philosophers; i++)
            philosophers.add(new Main(i));
        for(int i = 0; i < num_philosophers; i++)
            chopsticks.add(new ReentrantLock(false));
        for(Thread philosopher: philosophers)
            philosopher.start();
        for(Thread philosopher: philosophers) {
            try {
                philosopher.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public void run() {
        for(;;) {
            System.out.println("Philosopher " + philosopher_id + " is thinking.");
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
                        
            Lock leftChopstick = chopsticks.get(philosopher_id);
            Lock rightChopstick = chopsticks.get((philosopher_id + 1) % num_philosophers);
            
            leftChopstick.lock();
            try {
                rightChopstick.lock();
                try {
                    System.out.println("Philosopher " + philosopher_id + " is eating.");
                } finally {
                    rightChopstick.unlock();
                }
            } finally {
                System.out.println("Philosopher " + philosopher_id + " finished eating.");
                leftChopstick.unlock();
            }
        }
    }
}
        </pre>
        <h3>Answer Problem 1 Part 2</h3>
        <pre class="code-block">
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Main extends Thread {
    static int num_philosophers = 5;
    static List<Lock> chopsticks = new ArrayList<>();
    static int eat_time_millis = 500;
    
    int philosopher_id;
    
    public Main(int philosopher_id) {
        this.philosopher_id = philosopher_id;
    }
    
    public static void main(String[] args) {
        if(num_philosophers < 5) {
            System.out.println("num_philosophers must be at least 5!");
            return;
        }
        
        List<Thread> philosophers = new ArrayList<>();
        
        for(int i = 0; i < num_philosophers; i++)
            philosophers.add(new Main(i));
        for(int i = 0; i < num_philosophers; i++)
            chopsticks.add(new ReentrantLock(false));
        for(Thread philosopher: philosophers)
            philosopher.start();
        for(Thread philosopher: philosophers) {
            try {
                philosopher.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public void run() {
        for(;;) {
            System.out.println("Philosopher " + philosopher_id + " is thinking.");
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
            
            // each philospher gets lowest index lock first
            int first_chopstick_index = Math.min(philosopher_id, (philosopher_id + 1) % num_philosophers);
            int second_chopstick_index = Math.max(philosopher_id, (philosopher_id + 1) % num_philosophers);
                        
            Lock firstChopstick = chopsticks.get(first_chopstick_index);
            Lock secondChopstick = chopsticks.get(second_chopstick_index);
            
            firstChopstick.lock();
            try {
                secondChopstick.lock();
                try {
                    System.out.println("Philosopher " + philosopher_id + " is eating.");
                } finally {
                    secondChopstick.unlock();
                }
            } finally {
                System.out.println("Philosopher " + philosopher_id + " finished eating.");
                firstChopstick.unlock();
            }
        }
    }
}
        </pre>
        <h3>Answer Problem 1 Part 3</h3>
        <pre class="code-block">
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Main extends Thread {
    static int num_philosophers = 5;
    static List<Lock> chopsticks = new ArrayList<>();
    static int eat_time_millis = 500;
    
    int philosopher_id;
    
    public Main(int philosopher_id) {
        this.philosopher_id = philosopher_id;
    }
    
    public static void main(String[] args) {
        if(num_philosophers < 5) {
            System.out.println("num_philosophers must be at least 5!");
            return;
        }
        
        List<Thread> philosophers = new ArrayList<>();
        
        for(int i = 0; i < num_philosophers; i++)
            philosophers.add(new Main(i));
        for(int i = 0; i < num_philosophers; i++)
            chopsticks.add(new ReentrantLock(false));
        for(Thread philosopher: philosophers)
            philosopher.start();
        for(Thread philosopher: philosophers) {
            try {
                philosopher.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public void run() {
        for(;;) {
            System.out.println("Philosopher " + philosopher_id + " is thinking.");
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
            
            // each philospher gets lowest index lock first
            int first_chopstick_index = Math.min(philosopher_id, (philosopher_id + 1) % num_philosophers);
            int second_chopstick_index = Math.max(philosopher_id, (philosopher_id + 1) % num_philosophers);
                        
            Lock firstChopstick = chopsticks.get(first_chopstick_index);
            Lock secondChopstick = chopsticks.get(second_chopstick_index);
            
            firstChopstick.lock();
            try {
                secondChopstick.lock();
                try {
                    System.out.println("Philosopher " + philosopher_id + " is eating.");
                } finally {
                    secondChopstick.unlock();
                }
            } finally {
                System.out.println("Philosopher " + philosopher_id + " finished eating.");
                firstChopstick.unlock();
            }
        }
    }
}
        </pre>
        <h3>Answer Problem 1 Part 4</h3>
        <p>
            The previous code already works for n philosophers.
        </p>
        <h3>Problem 2</h3>
        <p>
            For each of the following, state whether it is a safety or liveness property.
            Identify the bad or good thing of interest.<br>
            1. Patrons are served in the order they arrive.<br>
            2. What goes up must come down.<br>
            3. If two or more processes are waiting to enter their critical sections, at least one succeeds.<br>
            4. If an interrupt occurs, then a message is printed within one second.<br>
            5. If an interrupt occurs, then a message is printed.<br>
            6. The cost of living never decreases.<br>
            7. Two things are certain: death and taxes.<br>
            8. You can always tell a Harvard man.
        </p>
        <h3>Answer Problem 2</h3>
        <p>
            1. Safety | Later patron is served before earlier.<br>
            2. Liveness | All things that go up eventually come down.<br>
            3. Liveness | One process eventually enters the critical section.<br>
            4. Liveness | Message is printed within one second after interrupt.<br>
            5. Liveness | Message is eventually printed after interrupt.<br>
            6. Safety | The cost of living increases.<br>
            7. Liveness | Eventually you die and pay taxes.<br>
            8. Safety | You can't tell the Harvard man.
        </p>

        <h3>Problem 3</h3>
        <p>
            In the producer-consumer fable, we assumed that Bob can see whether
            the can on Alice's windowsill is up or down. 
            Design a producer-consumer protocol using cans and strings 
            that works even if Bob cannot see the state of Alice's can 
            (this is how real-world interrupt bits work).
        </p>
        <h3>Answer Problem 3</h3>
        <p>
            Solution 1:<br>
            Bob can't see can<br>
            Can with string from Alice to Bob<br>
            Can with string from Bob to Alice<br><br>
            Initial state:<br>
            Alice can is up.<br>
            Bob's can is down.<br><br>
            Alice does the following:<br>
            1. She waits until her can is down.<br>
            2. She releases the pets.<br>
            3. When the pets return, Alice checks whether they finished the food. If so, she resets the can.<br>
            4. Knocks down Bob's can.<br><br>
            Bob does the following:<br>
            1. He waits until his can is down.<br>
            2. He puts food in the yard.<br>
            3. Resets his can.<br>
            4. He pulls the string and knocks Alice's can down.<br><br>
            Solution 2:<br>
            Bob can't see can's on Alice's window.<br><br>
            Initial state:<br>
            Bob can is down.<br><br>
            Alice does the following:<br>
            1. Waits until pets want food.<br>
            2. Waits until Bob's can is up.<br>
            3. Knocks over Bob's can.<br>
            4. Wait until can is back up.<br>
            5. She releases the pets.<br>
            6. Wait until the pets return.<br><br>
            Bob does the following:<br>
            1. He waits until his can is down.<br>
            2. He puts food in the yard.<br>
            3. Resets his can.
        </p>

        <h3>Problem 4</h3>
        <p>
            You are one of P recently arrested prisoners. The warden sets 
            up a “switch room” with a light switch (on/off). Prisoners enter 
            the room one at a time and may toggle or leave the switch unchanged. 
            Each prisoner visits arbitrarily often. Any prisoner may declare when all have visited.<br>
            Devise a winning strategy when you know the initial switch is off.<br>
            Devise a winning strategy when you do not know whether the initial state is on or off.
        </p>
        <h3>Answer Problem 4</h3>
        <p>
            If default state is off:<br>
            Designate the x'th prisoner as the counter.<br>
            Each prisoner on first visit:<br>
            - If switch is on, doesn't change it.<br>
            - If switch is off, flips switch on.<br>
            Each prisoner after first visit:<br>
            - Leaves switch unchanged.<br>
            When x prisoner enters:<br>
            - If switch is on, add 1 internally.<br>
            - If internal count is P - 1, announce all visited.<br><br>
            If default state unknown:<br>
            Modify solution so everyone counts twice.<br>
            Each prisoner waits until they count 2P prisoners.
        </p>

        <h3>Problem 5</h3>
        <p>
            The warden orders prisoners in a line, placing red or blue hats on each. 
            Each prisoner sees hats in front but not their own or behind. Starting 
            from the back, each guesses own hat color aloud. At least P-1 prisoners should be freed.<br>
            Devise a strategy.
        </p>
        <h3>Answer Problem 5</h3>
        <p>
            First person (back) says "red" if even number of reds, "blue" if odd.<br>
            The i'th person ignores the first person's color but counts the number 
            of reds behind and in front (call this x).<br>
            Two cases:<br>
            - First person said "red": Even number of red hats.<br>
            -- If x is odd, say "red", else say "blue".<br>
            - First person said "blue": Odd number of red hats.<br>
            -- If x is odd, say "blue", else say "red".
        </p>

        <h3>Problem 6</h3>
        <p>
            Use Amdahl's Law to resolve:<br>
            (a) Suppose a method M is non-parallelizable and accounts for 
            40% execution time. What's the overall speedup limit?<br>
            (b) If M accounts for 30%, what speedup must M have to double overall speed?<br>
            (c) If M can be sped up three-fold, what fraction must M be to double overall speed?
        </p>
        <h3>Answer Problem 6</h3>
        <p>
            Amdahl's Law = 1 / ((1 - p) + p / n) = s<br>
            (a) 40% serial, 60% parallel:<br>
            1 / ((1 - 0.6) + 0.6 / ∞) = 2.5x<br><br>
            (b) 1 / ((1 - 0.7) + 0.3 / n) = 2<br>
            Literally not possible, lol.<br><br>
            (c) x = % code sped up 3-fold<br>
            1 / ((1 - x) + x / 3) = 2<br>
            x = 75%
        </p>

        <h3>Problem 7</h3>
        <p>
            Running your application on two processors yields speedup 
            S<sub>2</sub>. Use Amdahl's Law to derive a formula for speedup S<sub>n</sub> 
            on n processors in terms of n and S<sub>2</sub>.
        </p>
        <h3>Answer Problem 7</h3>
        <p>
            1 / ((1 - p) + p / 2) = S<sub>2</sub><br>
            S<sub>2</sub> * ((1 - p) + p / 2) = 1<br>
            S<sub>2</sub> * (1 - p) + (S<sub>2</sub> * p) / 2 = 1<br>
            S<sub>2</sub> - S<sub>2</sub> p + (S<sub>2</sub> p) / 2 = 1<br>
            Multiply both sides by 2:<br>
            2 S<sub>2</sub> - 2 S<sub>2</sub> p + S<sub>2</sub> p = 2<br>
            Group p terms:<br>
            2 S<sub>2</sub> - S<sub>2</sub> p = 2<br>
            Rearrange:<br>
            - S<sub>2</sub> p = 2 - 2 S<sub>2</sub><br>
            Multiply both sides by -1:<br>
            S<sub>2</sub> p = 2 S<sub>2</sub> - 2<br>
            Divide both sides by S<sub>2</sub>:<br>
            p = 2 - (2 / S<sub>2</sub>)<br><br>
            Replug into Amdahl's Law:<br>
            S<sub>n</sub> = 1 / ((1 - p) + p / n) = 1 / ((1 - 
            (2 - 2 / S<sub>2</sub>)) + (2 - 2 / S<sub>2</sub>) / n)
        </p>

        <h3>Problem 8</h3>
        <p>
            You have a choice between buying one uniprocessor that executes 
            five zillion instructions per second, or a ten-processor multiprocessor 
            where each processor executes one zillion instructions per second. Using 
            Amdahl's Law, explain how you would decide which to buy for a particular application.
        </p>
        <h3>Answer Problem 8</h3>
        <p>
            Our application has 0 parallelizable code so we want the uniprocessor. 
            Multiple processor provides 0 speedup according to Amdahl's law because 
            0% of the code is parallelizable.
        </p>
    </body>
</html>